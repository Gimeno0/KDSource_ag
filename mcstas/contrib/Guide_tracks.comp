/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: McStas2Distrib_guide
*
* %I
* Written by: 
* Date: 
* Origin: 
*
* Neutron guide.
*
* %D
* Models a rectangular guide tube centered on the Z axis. The entrance lies
* in the X-Y plane.
* For details on the geometry calculation see the description in the McStas
* reference manual.
* The reflectivity profile may either use an analytical mode (see Component
* Manual) or a 2-columns reflectivity free text outfile with format
* [q(Angs-1) R(0-1)].
*
* Example: McStas2Distrib_guide(...)
*
* %VALIDATION
*
* %BUGS
* This component does not work with gravitation on. Use component Guide_gravity then.
*
* %P
* INPUT PARAMETERS:
*
* %D
* Example values: m=4 Qc=0.0219 W=1/300 alpha=6.49 R0=1
*
* %E
*******************************************************************************/

DEFINE COMPONENT Guide_tracks
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string pt="n", string filename="",
	xwidth=0.0, yheight=0.0, length=0.0, rcurv=0.0, 
	R0=0, Qc=0, alpha=0, m=0, W=0, 
	R0_1=0.99, Qc_1=0.0219, alpha_1=4.0, m_1=3.0, W_1=0.003, 
	R0_2=0.99, Qc_2=0.0219, alpha_2=4.0, m_2=3.0, W_2=0.003, 
	R0_3=0.99, Qc_3=0.0219, alpha_3=4.0, m_3=3.0, W_3=0.003, 
	R0_4=0.99, Qc_4=0.0219, alpha_4=4.0, m_4=3.0, W_4=0.003,
	string reflect="")
OUTPUT PARAMETERS (outfile, I, p2, N, pTable)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

SHARE
%{
	#include "mcpl.h"
	%include "read_table-lib"
	%include "ref-lib"
%}

DECLARE
%{
	mcpl_outfile_t outfile;
	double I, p2;
	int N;
	mcpl_particle_t* part;

	t_Table pTable; // Tabla de reflectividad
%}

INITIALIZE
%{
	if(strlen(filename) == 0) strcat(strcpy(filename, NAME_CURRENT_COMP), "_tracks");
	outfile = mcpl_create_outfile(filename);
	mcpl_hdr_set_srcname(outfile,"McStas Guide_tracks");
	mcpl_enable_universal_pdgcode(outfile, pt2pdg(pt[0]));

	part = mcpl_get_empty_particle(outfile);

	I = p2 = N = 0;

	if(!rcurv || rcurv==INFINITY) rcurv = 0;

	// Espejos iguales entre si
	if(R0 != 0){R0_1=R0; R0_2=R0; R0_3=R0; R0_4=R0;}
	if(Qc != 0){Qc_1=Qc; Qc_2=Qc; Qc_3=Qc; Qc_4=Qc;}
	if(alpha != 0){alpha_1=alpha; alpha_2=alpha; alpha_3=alpha; alpha_4=alpha;}
	if(m != 0){m_1=m; m_2=m; m_3=m; m_4=m;}
	if(W != 0){W_1=W; W_2=W; W_3=W; W_4=W;}
%}

TRACE
%{
	double t1, t2;                                          /* Intersection times. */
	int im;                                                 /* Which mirror hit? */
	double weight;                                          /* Internal probability weight */
	double q;                                               /* Q [1/AA] of reflection */
	// Variables en mayusculas representan variables absolutas, modelando a la guia como curvada
	// Variables en minusculas representan variables modificadas para enderezar la guia
	double a, b, c, X, Y, Z, VX, VY, VZ;
	
	PROP_Z0; /* Propagate neutron to guide entrance. */
	SCATTER; /* Scatter here to ensure that fully transmitted neutrons will not be absorbed in a GROUP construction, e.g. all neutrons - even the later absorbed ones are scattered at the guide entry. */
	if(x <= -xwidth/2. || x >= xwidth/2. || y <= -yheight/2. || y >= yheight/2.) ABSORB;

	while(1){
		
		// Determinar posicion y velocidad absolutas
		if(rcurv == 0){
			X = x; Y = y; Z = z;
			VX = vx; VY = vy; VZ = vz;
		}
		else{
			X = (rcurv+x)*cos(z/rcurv)-rcurv; Y = y; Z = (rcurv+x)*sin(z/rcurv);
			VX = vx*cos(z/rcurv)-vz*sin(z/rcurv); VY = vy; VZ = vx*sin(z/rcurv)+vz*cos(z/rcurv);
		}

		// Determinar tiempo de interseccion y cual espejo impacta
		if(rcurv == 0) t1 = (length - Z)/VZ;
		else t1 = ((rcurv+X)*tan(length/rcurv)-Z)/(VZ-VX*tan(length/rcurv));
		im = -1;
		if(rcurv == 0){
			if(vx > 0 && (t2 = (xwidth/2.-x)/vx) < t1){t1 = t2; im = 0;} // Positive x mirror
			if(vy > 0 && (t2 = (yheight/2.-y)/vy) < t1){t1 = t2; im = 1;} // Positive y mirror
			if(vx < 0 && (t2 = (x+xwidth/2.)/(-vx)) < t1){t1 = t2; im = 2;} // Negative x mirror
			if(vy < 0 && (t2 = (y+yheight/2.)/(-vy)) < t1){t1 = t2; im = 3;} // Negative y mirror
		}
		else{
			a = VX*VX+VZ*VZ; b = 2*((X+rcurv)*VX+Z*VZ); c = (X+rcurv)*(X+rcurv)+Z*Z-(rcurv+xwidth/2)*(rcurv+xwidth/2);
			if(b*b-4*a*c > 0 && ((t2 = (-b+sqrt(b*b-4*a*c))/(2*a)) < t1) && (t2 > 0)){ t1 = t2; im = 0; } // Positive x mirror
			if(VY > 0 && (t2 = (yheight/2 - Y)/VY) < t1){ t1 = t2; im = 1; } // Positive y mirror
			a = VX*VX+VZ*VZ; b = 2*((X+rcurv)*VX+Z*VZ); c = (X+rcurv)*(X+rcurv)+Z*Z-(rcurv-xwidth/2)*(rcurv-xwidth/2);
			if(b*b-4*a*c > 0 && ((t2 = (-b-sqrt(b*b-4*a*c))/(2*a)) < t1) && (t2 > 0)){ t1 = t2; im = 2; } // Negative x mirror
			if(VY < 0 && (t2 = (Y + yheight/2)/(-VY)) < t1){ t1 = t2; im = 3; } // Negative y mirror
		}

		// Propagar hasta interseccion
		if(rcurv == 0) PROP_DT(t1);
		else{
			x = sqrt((rcurv+X+VX*t1)*(rcurv+X+VX*t1) + (Z+VZ*t1)*(Z+VZ*t1)) - rcurv;
			y = Y + VY*t1;
			z = rcurv * atan2(Z+VZ*t1, rcurv+X+VX*t1);
			vx = VX*cos(z/rcurv) + VZ*sin(z/rcurv);
			vy = VY;
			vz = -VX*sin(z/rcurv) + VZ*cos(z/rcurv);
		}
		if(im == -1) break;                    /* Neutron left guide. */

		// Determinar nueva posicion y velocidad absolutas
		if(rcurv == 0){
			X = x; Y = y; Z = z;
			VX = vx; VY = vy; VZ = vz;
		}
		else{
			X = (rcurv+x)*cos(z/rcurv)-rcurv; Y = y; Z = (rcurv+x)*sin(z/rcurv);
			VX = vx*cos(z/rcurv)-vz*sin(z/rcurv); VY = vy; VZ = vx*sin(z/rcurv)+vz*cos(z/rcurv);
		}

		// Registrar neutron antes de reflexion
		double V2 = (VX*VX + VY*VY + VZ*VZ);
		double E = 1e-9 * VS2E * V2;
		double V = sqrt(V2);
		part->ekin = E;
		part->position[0] = X*100.0; part->position[1] = Y*100.0; part->position[2] = Z*100.0;
		part->direction[0] = VX/V; part->direction[1] = VY/V; part->direction[2] = VZ/V;

		// Reflejar en el espejo im
		switch(im){
		  	case 0:                   // Positive x mirror
		  		vx = -vx;
		    	q = V2Q*2*vx;
				weight = 1.0;
				if(reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) TableReflecFunc(q, &pTable, &weight);
				else{double par[] = {R0_1, Qc_1, alpha_1, m_1, W_1}; StdReflecFunc(q, par, &weight);}
				break;
		  	case 1:                   // Positive y mirror
		  		vy = -vy;
		    	q = V2Q*2*vy;
				weight = 1.0;
				if(reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) TableReflecFunc(q, &pTable, &weight);
				else{double par[] = {R0_2, Qc_2, alpha_2, m_2, W_2}; StdReflecFunc(q, par, &weight);}
		    	break;
		  	case 2:                   // Negative x mirror
		  		vx = -vx;
		    	q = V2Q*2*(-vx);
				weight = 1.0;
				if(reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) TableReflecFunc(q, &pTable, &weight);
				else{double par[] = {R0_3, Qc_3, alpha_3, m_3, W_3}; StdReflecFunc(q, par, &weight);}
		    	break;
		  	case 3:                   // Negative y mirror
		  		vy = -vy;
		    	q = V2Q*2*(-vy);
				weight = 1.0;
				if(reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) TableReflecFunc(q, &pTable, &weight);
				else{double par[] = {R0_4, Qc_4, alpha_4, m_4, W_4}; StdReflecFunc(q, par, &weight);}
		    	break;
		}

		// Registrar peso estadistico no reflejado y guardar
		part->weight = p*(1-weight);
		mcpl_add_particle(outfile, part);
		I += part->weight;
		p2 += part->weight*part->weight;
		N++;


		// Actualizar peso reflejado
		if(weight==0) ABSORB;
		p *= weight;
		SCATTER;
	}
%}

SAVE
%{
	printf("Guide_tracks %s: I err N %lf %lf %d\n", NAME_CURRENT_COMP, I, sqrt(p2), N);
%}

FINALLY
%{
	mcpl_closeandgzip_outfile(outfile);
%}

MCDISPLAY
%{
	multiline(5,
    	-xwidth/2.0, -yheight/2.0, 0.0,
    	 xwidth/2.0, -yheight/2.0, 0.0,
    	 xwidth/2.0,  yheight/2.0, 0.0,
    	-xwidth/2.0,  yheight/2.0, 0.0,
    	-xwidth/2.0, -yheight/2.0, 0.0);
	multiline(5,
		-xwidth/2.0, -yheight/2.0, (double)length,
		 xwidth/2.0, -yheight/2.0, (double)length,
		 xwidth/2.0,  yheight/2.0, (double)length,
		-xwidth/2.0,  yheight/2.0, (double)length,
		-xwidth/2.0, -yheight/2.0, (double)length);
	line(-xwidth/2.0, -yheight/2.0, 0, -xwidth/2.0, -yheight/2.0, (double)length);
	line( xwidth/2.0, -yheight/2.0, 0,  xwidth/2.0, -yheight/2.0, (double)length);
	line( xwidth/2.0,  yheight/2.0, 0,  xwidth/2.0,  yheight/2.0, (double)length);
	line(-xwidth/2.0,  yheight/2.0, 0, -xwidth/2.0,  yheight/2.0, (double)length);
%}

END
